{"version":3,"sources":["createStore.js"],"names":["define","$$observable","ActionTypes","isPlainObject","a","createStore","reducer","preloadedState","enhancer","arguments","Error","undefined","kindOf","currentReducer","currentState","currentListeners","nextListeners","isDispatching","ensureCanMutateNextListeners","slice","getState","subscribe","listener","isSubscribed","push","index","indexOf","splice","dispatch","action","type","listeners","i","length","INIT","replaceReducer","nextReducer","REPLACE","[object Object]","outerSubscribe","observer","TypeError","observeState","next","unsubscribe","this"],"mappings":";;;;;;;AAAAA,QACI,4BACA,sBACA,wBACA,kBACD,SAAUC,EAAcC,EAAaC,EAAeC,GACnD,aACA,OAAO,SAASC,EAAYC,EAASC,EAAgBC,GACjD,GAA8B,mBAAnBD,GAAqD,mBAAbC,GAA+C,mBAAbA,GAAmD,mBAAjBC,UAAU,GAC7H,MAAM,IAAIC,MAAM,oQAMpB,GAJ8B,mBAAnBH,QAAqD,IAAbC,IAC/CA,EAAWD,EACXA,OAAiBI,QAEG,IAAbH,EAA0B,CACjC,GAAwB,mBAAbA,EACP,MAAM,IAAIE,qEAAsEN,EAAEQ,OAAOJ,OAE7F,OAAOA,EAASH,EAATG,CAAsBF,EAASC,GAE1C,GAAuB,mBAAZD,EACP,MAAM,IAAII,yEAA0EN,EAAEQ,OAAON,OAEjG,IAAIO,EAAiBP,EACjBQ,EAAeP,EACfQ,KACAC,EAAgBD,EAChBE,GAAgB,EACpB,SAASC,IACDF,IAAkBD,IAClBC,EAAgBD,EAAiBI,SAGzC,SAASC,IACL,GAAIH,EACA,MAAM,IAAIP,MAAM,wMAEpB,OAAOI,EAEX,SAASO,EAAUC,GACf,GAAwB,mBAAbA,EACP,MAAM,IAAIZ,qEAAsEN,EAAEQ,OAAOU,OAE7F,GAAIL,EACA,MAAM,IAAIP,MAAM,mTAEpB,IAAIa,GAAe,EAGnB,OAFAL,IACAF,EAAcQ,KAAKF,GACZ,WACH,IAAKC,EACD,OAEJ,GAAIN,EACA,MAAM,IAAIP,MAAM,wJAEpBa,GAAe,EACfL,IACA,MAAMO,EAAQT,EAAcU,QAAQJ,GACpCN,EAAcW,OAAOF,EAAO,GAC5BV,EAAmB,MAG3B,SAASa,EAASC,GACd,IAAK1B,EAAc0B,GACf,MAAM,IAAInB,uEAAwEN,EAAEQ,OAAOiB,gVAE/F,QAA2B,IAAhBA,EAAOC,KACd,MAAM,IAAIpB,MAAM,8GAEpB,GAAIO,EACA,MAAM,IAAIP,MAAM,sCAEpB,IACIO,GAAgB,EAChBH,EAAeD,EAAeC,EAAce,GAC9C,QACEZ,GAAgB,EAEpB,MAAMc,EAAYhB,EAAmBC,EACrC,IAAK,IAAIgB,EAAI,EAAGA,EAAID,EAAUE,OAAQD,IAAK,EAEvCV,EADiBS,EAAUC,MAG/B,OAAOH,EA+BX,OADAD,GAAWE,KAAM5B,EAAYgC,QAEzBN,SAAAA,EACAP,UAAAA,EACAD,SAAAA,EACAe,eAjCJ,SAAwBC,GACpB,GAA2B,mBAAhBA,EACP,MAAM,IAAI1B,wEAAyEN,EAAEQ,OAAOwB,MAEhGvB,EAAiBuB,EACjBR,GAAWE,KAAM5B,EAAYmC,WA6B7BC,CAACrC,GA3BL,WACI,MAAMsC,EAAiBlB,EACvB,OACIiB,UAAUE,GACN,GAAwB,iBAAbA,GAAsC,OAAbA,EAChC,MAAM,IAAIC,wEAAyErC,EAAEQ,OAAO4B,OAEhG,SAASE,IACDF,EAASG,MACTH,EAASG,KAAKvB,KAKtB,OAFAsB,KAESE,YADWL,EAAeG,KAGvCJ,CAACrC,KACG,OAAO4C","file":"../createStore.js","sourcesContent":["define([\n    './utils/symbol-observable',\n    './utils/actionTypes',\n    './utils/isPlainObject',\n    './utils/kindOf'\n], function ($$observable, ActionTypes, isPlainObject, a) {\n    'use strict';\n    return function createStore(reducer, preloadedState, enhancer) {\n        if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {\n            throw new Error('It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.');\n        }\n        if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n            enhancer = preloadedState;\n            preloadedState = undefined;\n        }\n        if (typeof enhancer !== 'undefined') {\n            if (typeof enhancer !== 'function') {\n                throw new Error(`Expected the enhancer to be a function. Instead, received: '${ a.kindOf(enhancer) }'`);\n            }\n            return enhancer(createStore)(reducer, preloadedState);\n        }\n        if (typeof reducer !== 'function') {\n            throw new Error(`Expected the root reducer to be a function. Instead, received: '${ a.kindOf(reducer) }'`);\n        }\n        let currentReducer = reducer;\n        let currentState = preloadedState;\n        let currentListeners = [];\n        let nextListeners = currentListeners;\n        let isDispatching = false;\n        function ensureCanMutateNextListeners() {\n            if (nextListeners === currentListeners) {\n                nextListeners = currentListeners.slice();\n            }\n        }\n        function getState() {\n            if (isDispatching) {\n                throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');\n            }\n            return currentState;\n        }\n        function subscribe(listener) {\n            if (typeof listener !== 'function') {\n                throw new Error(`Expected the listener to be a function. Instead, received: '${ a.kindOf(listener) }'`);\n            }\n            if (isDispatching) {\n                throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api/store#subscribelistener for more details.');\n            }\n            let isSubscribed = true;\n            ensureCanMutateNextListeners();\n            nextListeners.push(listener);\n            return function unsubscribe() {\n                if (!isSubscribed) {\n                    return;\n                }\n                if (isDispatching) {\n                    throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api/store#subscribelistener for more details.');\n                }\n                isSubscribed = false;\n                ensureCanMutateNextListeners();\n                const index = nextListeners.indexOf(listener);\n                nextListeners.splice(index, 1);\n                currentListeners = null;\n            };\n        }\n        function dispatch(action) {\n            if (!isPlainObject(action)) {\n                throw new Error(`Actions must be plain objects. Instead, the actual type was: '${ a.kindOf(action) }'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.`);\n            }\n            if (typeof action.type === 'undefined') {\n                throw new Error('Actions may not have an undefined \"type\" property. You may have misspelled an action type string constant.');\n            }\n            if (isDispatching) {\n                throw new Error('Reducers may not dispatch actions.');\n            }\n            try {\n                isDispatching = true;\n                currentState = currentReducer(currentState, action);\n            } finally {\n                isDispatching = false;\n            }\n            const listeners = currentListeners = nextListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                const listener = listeners[i];\n                listener();\n            }\n            return action;\n        }\n        function replaceReducer(nextReducer) {\n            if (typeof nextReducer !== 'function') {\n                throw new Error(`Expected the nextReducer to be a function. Instead, received: '${ a.kindOf(nextReducer) }`);\n            }\n            currentReducer = nextReducer;\n            dispatch({ type: ActionTypes.REPLACE });\n        }\n        function observable() {\n            const outerSubscribe = subscribe;\n            return {\n                subscribe(observer) {\n                    if (typeof observer !== 'object' || observer === null) {\n                        throw new TypeError(`Expected the observer to be an object. Instead, received: '${ a.kindOf(observer) }'`);\n                    }\n                    function observeState() {\n                        if (observer.next) {\n                            observer.next(getState());\n                        }\n                    }\n                    observeState();\n                    const unsubscribe = outerSubscribe(observeState);\n                    return { unsubscribe };\n                },\n                [$$observable]() {\n                    return this;\n                }\n            };\n        }\n        dispatch({ type: ActionTypes.INIT });\n        return {\n            dispatch,\n            subscribe,\n            getState,\n            replaceReducer,\n            [$$observable]: observable\n        };\n    };\n});"]}