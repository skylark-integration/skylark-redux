{"version":3,"sources":["combineReducers.js"],"names":["define","ActionTypes","warning","isPlainObject","a","reducers","reducerKeys","Object","keys","finalReducers","i","length","key","process","env","NODE_ENV","finalReducerKeys","unexpectedKeyCache","shapeAssertionError","forEach","reducer","undefined","type","INIT","Error","PROBE_UNKNOWN_ACTION","assertReducerShape","e","state","action","warningMessage","inputState","argumentName","kindOf","join","unexpectedKeys","filter","hasOwnProperty","REPLACE","getUnexpectedStateShapeWarningMessage","hasChanged","nextState","previousStateForKey","nextStateForKey","actionType","String"],"mappings":";;;;;;;AAAAA,QACI,sBACA,kBACA,wBACA,kBACD,SAAUC,EAAaC,EAASC,EAAeC,GAC9C,aAgCA,OAAO,SAAyBC,GAC5B,MAAMC,EAAcC,OAAOC,KAAKH,GAC1BI,KACN,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAAYK,OAAQD,IAAK,CACzC,MAAME,EAAMN,EAAYI,GACK,eAAzBG,QAAQC,IAAIC,eACiB,IAAlBV,EAASO,IAChBV,kCAAyCU,MAGpB,mBAAlBP,EAASO,KAChBH,EAAcG,GAAOP,EAASO,IAGtC,MAAMI,EAAmBT,OAAOC,KAAKC,GACrC,IAAIQ,EAIAC,EAHyB,eAAzBL,QAAQC,IAAIC,WACZE,MAGJ,KAhCJ,SAA4BZ,GACxBE,OAAOC,KAAKH,GAAUc,QAAQP,IAC1B,MAAMQ,EAAUf,EAASO,GAEzB,QAA4B,IADPQ,OAAQC,GAAaC,KAAMrB,EAAYsB,OAExD,MAAM,IAAIC,oCAAqCZ,gDAAqD,oOAExG,QAAgF,IAArEQ,OAAQC,GAAaC,KAAMrB,EAAYwB,yBAC9C,MAAM,IAAID,oCAAqCZ,iFAAuFX,EAAYsB,uCAA0C,kRAyBhMG,CAAmBjB,GACrB,MAAOkB,GACLT,EAAsBS,EAE1B,OAAO,SAAqBC,KAAYC,GACpC,GAAIX,EACA,MAAMA,EAEV,GAA6B,eAAzBL,QAAQC,IAAIC,SAA2B,CACvC,MAAMe,EA7DlB,SAA+CC,EAAY1B,EAAUwB,EAAQZ,GACzE,MAAMX,EAAcC,OAAOC,KAAKH,GAC1B2B,EAAeH,GAAUA,EAAOP,OAASrB,EAAYsB,KAAO,gDAAkD,yCACpH,GAA2B,IAAvBjB,EAAYK,OACZ,MAAO,gIAEX,IAAKR,EAAc4B,GACf,aAAeC,6BAA0C5B,EAAE6B,OAAOF,uEAAoFzB,EAAY4B,KAAK,WAE3K,MAAMC,EAAiB5B,OAAOC,KAAKuB,GAAYK,OAAOxB,IAAQP,EAASgC,eAAezB,KAASK,EAAmBL,IAIlH,OAHAuB,EAAehB,QAAQP,IACnBK,EAAmBL,IAAO,IAE1BiB,GAAUA,EAAOP,OAASrB,EAAYqC,aAA1C,EAEIH,EAAexB,OAAS,gBACFwB,EAAexB,OAAS,EAAI,OAAS,aAAiBwB,EAAeD,KAAK,qBAAuBF,MAAoB,+DAAkE1B,EAAY4B,KAAK,kDADlO,EA8C+BK,CAAsCX,EAAOnB,EAAeoB,EAAQZ,GACvFa,GACA5B,EAAQ4B,GAGhB,IAAIU,GAAa,EACjB,MAAMC,KACN,IAAK,IAAI/B,EAAI,EAAGA,EAAIM,EAAiBL,OAAQD,IAAK,CAC9C,MAAME,EAAMI,EAAiBN,GACvBU,EAAUX,EAAcG,GACxB8B,EAAsBd,EAAMhB,GAC5B+B,EAAkBvB,EAAQsB,EAAqBb,GACrD,QAA+B,IAApBc,EAAiC,CACxC,MAAMC,EAAaf,GAAUA,EAAOP,KACpC,MAAM,IAAIE,4CAA6CoB,MAAkBC,OAAOD,MAAkB,gDAAkDhC,0BAA+B,4JAEvL6B,EAAU7B,GAAO+B,EACjBH,EAAaA,GAAcG,IAAoBD,EAGnD,OADAF,EAAaA,GAAcxB,EAAiBL,SAAWJ,OAAOC,KAAKoB,GAAOjB,QACtD8B,EAAYb","file":"../combineReducers.js","sourcesContent":["define([\n    './utils/actionTypes',\n    './utils/warning',\n    './utils/isPlainObject',\n    './utils/kindOf'\n], function (ActionTypes, warning, isPlainObject, a) {\n    'use strict';\n    function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n        const reducerKeys = Object.keys(reducers);\n        const argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';\n        if (reducerKeys.length === 0) {\n            return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\n        }\n        if (!isPlainObject(inputState)) {\n            return `The ${ argumentName } has unexpected type of \"${ a.kindOf(inputState) }\". Expected argument to be an object with the following ` + `keys: \"${ reducerKeys.join('\", \"') }\"`;\n        }\n        const unexpectedKeys = Object.keys(inputState).filter(key => !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]);\n        unexpectedKeys.forEach(key => {\n            unexpectedKeyCache[key] = true;\n        });\n        if (action && action.type === ActionTypes.REPLACE)\n            return;\n        if (unexpectedKeys.length > 0) {\n            return `Unexpected ${ unexpectedKeys.length > 1 ? 'keys' : 'key' } ` + `\"${ unexpectedKeys.join('\", \"') }\" found in ${ argumentName }. ` + `Expected to find one of the known reducer keys instead: ` + `\"${ reducerKeys.join('\", \"') }\". Unexpected keys will be ignored.`;\n        }\n    }\n    function assertReducerShape(reducers) {\n        Object.keys(reducers).forEach(key => {\n            const reducer = reducers[key];\n            const initialState = reducer(undefined, { type: ActionTypes.INIT });\n            if (typeof initialState === 'undefined') {\n                throw new Error(`The slice reducer for key \"${ key }\" returned undefined during initialization. ` + `If the state passed to the reducer is undefined, you must ` + `explicitly return the initial state. The initial state may ` + `not be undefined. If you don't want to set a value for this reducer, ` + `you can use null instead of undefined.`);\n            }\n            if (typeof reducer(undefined, { type: ActionTypes.PROBE_UNKNOWN_ACTION() }) === 'undefined') {\n                throw new Error(`The slice reducer for key \"${ key }\" returned undefined when probed with a random type. ` + `Don't try to handle '${ ActionTypes.INIT }' or other actions in \"redux/*\" ` + `namespace. They are considered private. Instead, you must return the ` + `current state for any unknown actions, unless it is undefined, ` + `in which case you must return the initial state, regardless of the ` + `action type. The initial state may not be undefined, but can be null.`);\n            }\n        });\n    }\n    return function combineReducers(reducers) {\n        const reducerKeys = Object.keys(reducers);\n        const finalReducers = {};\n        for (let i = 0; i < reducerKeys.length; i++) {\n            const key = reducerKeys[i];\n            if (process.env.NODE_ENV !== 'production') {\n                if (typeof reducers[key] === 'undefined') {\n                    warning(`No reducer provided for key \"${ key }\"`);\n                }\n            }\n            if (typeof reducers[key] === 'function') {\n                finalReducers[key] = reducers[key];\n            }\n        }\n        const finalReducerKeys = Object.keys(finalReducers);\n        let unexpectedKeyCache;\n        if (process.env.NODE_ENV !== 'production') {\n            unexpectedKeyCache = {};\n        }\n        let shapeAssertionError;\n        try {\n            assertReducerShape(finalReducers);\n        } catch (e) {\n            shapeAssertionError = e;\n        }\n        return function combination(state = {}, action) {\n            if (shapeAssertionError) {\n                throw shapeAssertionError;\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                const warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\n                if (warningMessage) {\n                    warning(warningMessage);\n                }\n            }\n            let hasChanged = false;\n            const nextState = {};\n            for (let i = 0; i < finalReducerKeys.length; i++) {\n                const key = finalReducerKeys[i];\n                const reducer = finalReducers[key];\n                const previousStateForKey = state[key];\n                const nextStateForKey = reducer(previousStateForKey, action);\n                if (typeof nextStateForKey === 'undefined') {\n                    const actionType = action && action.type;\n                    throw new Error(`When called with an action of type ${ actionType ? `\"${ String(actionType) }\"` : '(unknown type)' }, the slice reducer for key \"${ key }\" returned undefined. ` + `To ignore an action, you must explicitly return the previous state. ` + `If you want this reducer to hold no value, you can return null instead of undefined.`);\n                }\n                nextState[key] = nextStateForKey;\n                hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n            }\n            hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;\n            return hasChanged ? nextState : state;\n        };\n    };\n});"]}