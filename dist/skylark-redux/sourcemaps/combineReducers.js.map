{"version":3,"sources":["combineReducers.js"],"names":["define","ActionTypes","warning","isPlainObject","a","reducers","reducerKeys","Object","keys","finalReducers","i","length","key","finalReducerKeys","unexpectedKeyCache","shapeAssertionError","forEach","reducer","undefined","type","INIT","Error","PROBE_UNKNOWN_ACTION","assertReducerShape","e","state","action","warningMessage","inputState","argumentName","kindOf","join","unexpectedKeys","filter","hasOwnProperty","REPLACE","getUnexpectedStateShapeWarningMessage","hasChanged","nextState","previousStateForKey","nextStateForKey","actionType","String"],"mappings":";;;;;;;AAAAA,QACI,sBACA,kBACA,wBACA,kBACD,SAAUC,EAAaC,EAASC,EAAeC,GAC9C,aAgCA,OAAO,SAAyBC,GAC5B,MAAMC,EAAcC,OAAOC,KAAKH,GAC1BI,KACN,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAAYK,OAAQD,IAAK,CACzC,MAAME,EAAMN,EAAYI,QACK,IAAlBL,EAASO,IAChBV,kCAAyCU,MAEhB,mBAAlBP,EAASO,KAChBH,EAAcG,GAAOP,EAASO,IAGtC,MAAMC,EAAmBN,OAAOC,KAAKC,GACrC,IAAIK,EAIAC,EAFJD,KAGA,KA9BJ,SAA4BT,GACxBE,OAAOC,KAAKH,GAAUW,QAAQJ,IAC1B,MAAMK,EAAUZ,EAASO,GAEzB,QAA4B,IADPK,OAAQC,GAAaC,KAAMlB,EAAYmB,OAExD,MAAM,IAAIC,oCAAqCT,gDAAqD,oOAExG,QAAgF,IAArEK,OAAQC,GAAaC,KAAMlB,EAAYqB,yBAC9C,MAAM,IAAID,oCAAqCT,iFAAuFX,EAAYmB,uCAA0C,kRAuBhMG,CAAmBd,GACrB,MAAOe,GACLT,EAAsBS,EAE1B,OAAO,SAAqBC,KAAYC,GACpC,GAAIX,EACA,MAAMA,EAEV,MAAMY,EA1Dd,SAA+CC,EAAYvB,EAAUqB,EAAQZ,GACzE,MAAMR,EAAcC,OAAOC,KAAKH,GAC1BwB,EAAeH,GAAUA,EAAOP,OAASlB,EAAYmB,KAAO,gDAAkD,yCACpH,GAA2B,IAAvBd,EAAYK,OACZ,MAAO,gIAEX,IAAKR,EAAcyB,GACf,aAAeC,6BAA0CzB,EAAE0B,OAAOF,uEAAoFtB,EAAYyB,KAAK,WAE3K,MAAMC,EAAiBzB,OAAOC,KAAKoB,GAAYK,OAAOrB,IAAQP,EAAS6B,eAAetB,KAASE,EAAmBF,IAIlH,OAHAoB,EAAehB,QAAQJ,IACnBE,EAAmBF,IAAO,IAE1Bc,GAAUA,EAAOP,OAASlB,EAAYkC,aAA1C,EAEIH,EAAerB,OAAS,gBACFqB,EAAerB,OAAS,EAAI,OAAS,aAAiBqB,EAAeD,KAAK,qBAAuBF,MAAoB,+DAAkEvB,EAAYyB,KAAK,kDADlO,EA2C2BK,CAAsCX,EAAOhB,EAAeiB,EAAQZ,GACvFa,GACAzB,EAAQyB,GAEZ,IAAIU,GAAa,EACjB,MAAMC,KACN,IAAK,IAAI5B,EAAI,EAAGA,EAAIG,EAAiBF,OAAQD,IAAK,CAC9C,MAAME,EAAMC,EAAiBH,GACvBO,EAAUR,EAAcG,GACxB2B,EAAsBd,EAAMb,GAC5B4B,EAAkBvB,EAAQsB,EAAqBb,GACrD,QAA+B,IAApBc,EAAiC,CACxC,MAAMC,EAAaf,GAAUA,EAAOP,KACpC,MAAM,IAAIE,4CAA6CoB,MAAkBC,OAAOD,MAAkB,gDAAkD7B,0BAA+B,4JAEvL0B,EAAU1B,GAAO4B,EACjBH,EAAaA,GAAcG,IAAoBD,EAGnD,OADAF,EAAaA,GAAcxB,EAAiBF,SAAWJ,OAAOC,KAAKiB,GAAOd,QACtD2B,EAAYb","file":"../combineReducers.js","sourcesContent":["define([\n    './utils/actionTypes',\n    './utils/warning',\n    './utils/isPlainObject',\n    './utils/kindOf'\n], function (ActionTypes, warning, isPlainObject, a) {\n    'use strict';\n    function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n        const reducerKeys = Object.keys(reducers);\n        const argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';\n        if (reducerKeys.length === 0) {\n            return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\n        }\n        if (!isPlainObject(inputState)) {\n            return `The ${ argumentName } has unexpected type of \"${ a.kindOf(inputState) }\". Expected argument to be an object with the following ` + `keys: \"${ reducerKeys.join('\", \"') }\"`;\n        }\n        const unexpectedKeys = Object.keys(inputState).filter(key => !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]);\n        unexpectedKeys.forEach(key => {\n            unexpectedKeyCache[key] = true;\n        });\n        if (action && action.type === ActionTypes.REPLACE)\n            return;\n        if (unexpectedKeys.length > 0) {\n            return `Unexpected ${ unexpectedKeys.length > 1 ? 'keys' : 'key' } ` + `\"${ unexpectedKeys.join('\", \"') }\" found in ${ argumentName }. ` + `Expected to find one of the known reducer keys instead: ` + `\"${ reducerKeys.join('\", \"') }\". Unexpected keys will be ignored.`;\n        }\n    }\n    function assertReducerShape(reducers) {\n        Object.keys(reducers).forEach(key => {\n            const reducer = reducers[key];\n            const initialState = reducer(undefined, { type: ActionTypes.INIT });\n            if (typeof initialState === 'undefined') {\n                throw new Error(`The slice reducer for key \"${ key }\" returned undefined during initialization. ` + `If the state passed to the reducer is undefined, you must ` + `explicitly return the initial state. The initial state may ` + `not be undefined. If you don't want to set a value for this reducer, ` + `you can use null instead of undefined.`);\n            }\n            if (typeof reducer(undefined, { type: ActionTypes.PROBE_UNKNOWN_ACTION() }) === 'undefined') {\n                throw new Error(`The slice reducer for key \"${ key }\" returned undefined when probed with a random type. ` + `Don't try to handle '${ ActionTypes.INIT }' or other actions in \"redux/*\" ` + `namespace. They are considered private. Instead, you must return the ` + `current state for any unknown actions, unless it is undefined, ` + `in which case you must return the initial state, regardless of the ` + `action type. The initial state may not be undefined, but can be null.`);\n            }\n        });\n    }\n    return function combineReducers(reducers) {\n        const reducerKeys = Object.keys(reducers);\n        const finalReducers = {};\n        for (let i = 0; i < reducerKeys.length; i++) {\n            const key = reducerKeys[i];\n            if (typeof reducers[key] === 'undefined') {\n                warning(`No reducer provided for key \"${ key }\"`);\n            }\n            if (typeof reducers[key] === 'function') {\n                finalReducers[key] = reducers[key];\n            }\n        }\n        const finalReducerKeys = Object.keys(finalReducers);\n        let unexpectedKeyCache;\n\n        unexpectedKeyCache = {};\n\n        let shapeAssertionError;\n        try {\n            assertReducerShape(finalReducers);\n        } catch (e) {\n            shapeAssertionError = e;\n        }\n        return function combination(state = {}, action) {\n            if (shapeAssertionError) {\n                throw shapeAssertionError;\n            }\n            const warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\n            if (warningMessage) {\n                warning(warningMessage);\n            }\n            let hasChanged = false;\n            const nextState = {};\n            for (let i = 0; i < finalReducerKeys.length; i++) {\n                const key = finalReducerKeys[i];\n                const reducer = finalReducers[key];\n                const previousStateForKey = state[key];\n                const nextStateForKey = reducer(previousStateForKey, action);\n                if (typeof nextStateForKey === 'undefined') {\n                    const actionType = action && action.type;\n                    throw new Error(`When called with an action of type ${ actionType ? `\"${ String(actionType) }\"` : '(unknown type)' }, the slice reducer for key \"${ key }\" returned undefined. ` + `To ignore an action, you must explicitly return the previous state. ` + `If you want this reducer to hold no value, you can return null instead of undefined.`);\n                }\n                nextState[key] = nextStateForKey;\n                hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n            }\n            hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;\n            return hasChanged ? nextState : state;\n        };\n    };\n});"]}